<!DOCTYPE html>
<html>
<head>
	<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
	<meta charset="UTF-8">
</head>
<body>
	<div id="response">	
		<div><input type="text" v-model="site_to_add"><button type="button" v-on:click="add(site_to_add)">Add new site</button><button type="button" @click="update()">Update</button></div>
		<div class="panel" v-for="site in sites" v-bind:key="site[3]">		<!-- Making our key a predefined id instead of index because of mutability or something, i don't know i read it on the internet -->
			<div class="tag-form" :id="'tf'+site[3]" style="display: block;">
				<label for="tags">Tags to include</label><input name="tags" type="text" :id="'tt'+site[3]"><button type="button" @click="editTags(site)">Edit 2</button> <!--WHY "EDIT 2"? what is the right flow for this interaction?-->
				<!-- tf is tag form, tt is tag text -->
			</div>
			<h2>{{ site[0] }}</h2><button type="button" @click="toggleForm(site)" class="floatyboy">Edit</button>
			<question-individual
			v-for="question in site[2]"
			v-bind:key="question.question_id"
			v-bind:q="question"
			></question-individual>
		</div>
	</div>
<!--Sorry these comments are bad I wanted them to be inline but HTML doesn't really support that. Try reading one line of code for each line of comment here for the entire response div.
response is our Vue enabled div, see var stack_response
v-for="(site, name) in sites" iterates where site is a value (one div for each value) and name is a key in the object sites. I don't know what key really does but vue insists we have it. @click is the on-click listener.
mustache notation, inserts value of var as text.
<question-individual></question-individual> is a custom vue component, represents one question.
v-for statement places one of these for each question in stack_response.response
v-bind creates a property and sets the value based on the javascript value assigned it. In this case, property q takes on the value of 'question' from the for loop.
-->
<script>
function templateReq(site, tags)																//template for http requests
{
	let str = `https://api.stackexchange.com/2.2/questions?order=desc&sort=creation&site=${site}`
	if (tags.length) {
		str = str + "&tagged=" + tags.join(';')
	}
	return str
}

function httpGetAsync(theUrl, callback)													//create http GET request to theUrl and call callback when the information is received. Got this from stack overflow.
{
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() { 
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200)		//if the GET request actually returns something good.
            callback(xmlHttp.responseText);											//call "callback" with the response as a parameter.
    }
    xmlHttp.open("GET", theUrl, true); 													// true for asynchronous.
    xmlHttp.send(null);
}

var stack_response = new Vue({																	//creates a Vue instance to be accessible from elements with the tag provided through el.
	el: "#response",
	data: {																												//data is retrievable from the instance as toplevel variables, meaning you can call update() instead of stack_response.update() or stack_response.data.update() (within the actual instance. Outside of the instance you can retrieve it like stack_response.update();)
		sites: [																										
			['stackoverflow', [], [], 0],
			['serverfault', [], [], 1]														//left these as examples while I work on being able to add your own programatically. Right now, there is stackoverflow, unix&linux, and database administrator.
																																//[site name (str), tags (array), response (array), id (type tbd)]	//site name is the domain or subdomain without stackexchange's root domain. So dba.stackexchange.com -> dba, serverfault.com -> serverfault.
		],
		update: function() {																				//function to get questions from each site added to this instance.
			for (let site of stack_response.sites) {
				httpGetAsync(templateReq(site[0], site[1]), function(ret) {Vue.set(site, 2, JSON.parse(ret).items);});			//0 = site name, 1 = tags, 2 = space for response
			}
			console.log("Updated");
		},
		site_to_add: ""
	},
	methods: {
		add: function(site) {
			this.sites.push([site, [], [], this.sites.length]);
			stack_response.update();
		},
		editTags: function(site) {
			let t = document.getElementById('tt'+site[3]).value;
			Vue.set(site, 1, t.split(", "));
		},
		toggleForm: function(site) {
			let s = document.getElementById("tf" + site[3]);
			if (s.style.display === "none") {
				s.style.display = "block";
			} else {
				s.style.display = "none";
			}
		}
	}
})

Vue.component('question-individual', {											//custom component to be called as a tag in HTML.
	props: ['q'],																							//a property inserted in the tag when called.
	template: `
	<div class="question">
		<p>
		<a target="_blank" :href="q.link">{{ q.title }}</a><br>
			{{ new Date(q.creation_date *1000).toLocaleString() }} {{q.tags}} <span :class="'answered'+q.is_answered">Answered: {{ q.is_answered}}</span>
		</p>
	</div>
	`																													//template is what is inserted for the tag. It must be a singular node (in this case div) with unlimited children. Mustache notation applies here and data is inherited from props.
})

stack_response.update();
</script>
<style>
	.panel {
		background-color: #669999;
		width: 345px;
		height: 875px;
		overflow: auto;
		float: left;
		margin: 10px;
		padding: 5px;
	}
	a {
		color: black;
	}
	.answeredtrue {
		color: darkgreen;
	}
	.answeredfalse {
		color: red;
	}
	input {
		margin: 5px;
	}
	button {
		margin-left: 5px;
	}
	.floatyboy {
		float: right;
	}
	h2 {
		display: inline;
	}
	.tag-form {
		display: block;
	}
</style>
</body>
</html>
